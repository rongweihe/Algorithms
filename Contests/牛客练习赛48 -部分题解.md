# 牛客练习赛48 -部分题解

A 题 

链接：

https://ac.nowcoder.com/acm/contest/923/A

来源：牛客网

## 题目描述   

  大家一定都做过各大oj上面不同版本的A+B problem，如果现在反过来给你c，请你给我输出一组a和b，使得a+b的和等于c呢？  

  这同样还是一个简单的问题。  

  
   

  我们假设某种语言中的32位整形被定义成int 类型，该语言中负整数以二进制补码的形式储存，第32位为符号位，前31位为数值位。例如-1就被存储为"1111 1111 1111 1111 1111 1111 1111 1111"，-8则被储存为"1111 1111 1111 1111 1111 1111 1111 1000"，特别的，32位整形所能表示的最大负数-2147483648则被储存为"1000 0000 0000 0000 0000 0000 0000 0000"。  

  
   

  计算机在做加法运算时，实际上执行的是补码的加法运算，在计算的过程中如果数字溢出到不存在的第33位，那么这个溢出的位就不要了。  

  
   

  现在给你一个32位的负整形c。即c∈[−2147483648,−1]c∈[−2147483648,−1]。  

  请你给我两个32位的正整形a,b即a,b∈[1,2147483647]a,b∈[1,2147483647]。使得a+b=c。  

  如果不存在这样的a和b的话，请输出一个字符串"No solution"。否则请输出任意两个正整形a,b满足a+b=c。两个整数之间用一个空格隔开。  

## 输入描述:

```
仅一行一个32位负整形c,(−2147483648⩽c⩽−1)(−2147483648⩽c⩽−1)
```

## 输出描述:

```
如果存在两个32位正整形a,b使得a+b=c成立，则输出这两个正整形。

反之请输出一个字符串"No solution"。（不含引号）
```

 示例1 

## 输入

复制

```
-182
```

## 输出

复制

```
2147483647 2147483467
```

## 说明

```
a=2147483647="0111 1111 1111 1111 1111 1111 1111 1111"
b=2147483467="0111 1111 1111 1111 1111 1111 0100 1011"
c=-182="1111 1111 1111 1111 1111 1111 0100 1010"
a+b=c
```

## 备注:

```
如存在多解，你可以输出任意解。

你可以使用c语言的int类型来验证构造答案的正确性。
```

【思路】随意构造一个解即可。

【参考代码】

```c++
//github.com/rongweihe
#include <bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c;
    scanf("%d",&c);
    if(c==-1)puts("No solution");
    else{
        a=2147483647;b=c-a;
        printf("%d %d\n",a,b);
    }
    return 0;
}
```



B 题  小w的a=b问题

链接：

https://ac.nowcoder.com/acm/contest/923/B

来源：牛客网

## 题目描述   

给你两个数组，一个a[]a[]数组，长度为n，另一个是b[]b[]数组，长度为m。
 现在问你∏ni=1a[i]!∏i=1na[i]!是否等于∏mi=1b[i]!∏i=1mb[i]!
 其中∏∏是连乘符，它表示n个元素的乘积。"!"为阶乘运算，表示小于等于该数所有正整数的积，并且规定0!=1。
 我们认为阶乘运算"!"的优先级大于连乘运算"∏∏"。

## 输入描述:

```
第一行是一个正整数T，(1⩽T⩽2∗102)(1⩽T⩽2∗102)表示案例的数目
对于每组案例，第一行是两个正整数n,m，(1⩽n,m⩽105)(1⩽n,m⩽105)。
接下来一行输入n个整数a[i]，(0⩽a[i]⩽105)(0⩽a[i]⩽105)。

接下来一行输入m个整数b[i]，(0⩽b[i]⩽105)(0⩽b[i]⩽105)。
保证n,m的总和不多于2∗1062∗106
```

## 输出描述:

```
对于每组案例，输出一行一个字符串，如果∏ni=1a[i]!∏i=1na[i]!等于∏mi=1b[i]!∏i=1mb[i]!，请输出"equal"。
反之请输出"unequal"。
```

 示例1 

## 输入

复制

```
3
2 1
5 3
6
4 6
4 2 3 0
2 3 2 2 1 3
3 4
5 6 7
3 4 5 6
```

## 输出

复制

```
equal
equal
unequal
```

## 说明

```
对于第一组案例：
5!*3!=1*2*3*4*5*1*2*3=720
6!=1*2*3*4*5*6=720
完全相等。
对于第二组案例：
4!*2!*3!*0!=1*2*3*4*1*2*1*2*3*1=288
2!*3!*2!*2!*1!*3!=1*2*1*2*3*1*2*1*2*1*1*2*3=288
完全相等。
对于第三组案例：
5!*6!*7!=435456000
3!*4!*5!*6!=12441600
两者不等。
```

【思路】直接写会超时爆 int；预处理+哈希取模判断（不得不佩服AK大佬，菜鸡太弱）

【参考代码】

```c++
//github.com/rongweihe
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5+233,md1=1e9+7,md2=1e9+9;
int n,m,t,fac1[maxn],fac2[maxn];
void init(){
    fac1[0]=fac2[0]=1;
    for(int i=1; i<maxn; ++i){
        fac1[i] = (long long) fac1[i-1]*i%md1;
        fac2[i] = (long long) fac2[i-1]*i%md2;
    }
}
int main(){
    //freopen("in.txt","r",stdin);
    init();
    cin>>t;
    while(t--){
        cin>>n>>m;
        int v,x1=1,x2=1,y1=1,y2=1;
        for(int i=1; i<=n; ++i){
            cin>>v;
            x1 = (long long) x1*fac1[v]%md1;
            x2 = (long long) x2*fac2[v]%md2;
        }
        for(int i=1; i<=m; ++i){
            cin>>v;
            y1 = (long long) y1*fac1[v]%md1;
            y2 = (long long) y2*fac2[v]%md2;
        }
        cout << (x1 == y1 && x2 == y2 ? "equal" : "unequal") <<endl;
    }
    return 0;
}
```

