阿里面试官您好，对于 4. 24 号 中午的面试，首先跟面试官说一声辛苦了，非常感谢面试官给我这次电话面试的机会。

虽然只有短短的 30 来分钟，但是在这个过程中，我感受到了面试官资深的技术水平以及谦和有耐心的为人，虽然好几次我都没有正确的回答出面试官您的问题，但是在这个过程中，面试官您一直对我都有很有耐心，跟我说没关系，这点我真的感觉阿里的面试官挺好的，也一定程度上缓解了自己的紧张。

最后一个问题我回答还没完毕，手机就因为没电自动关机了，在这里，跟面试官说一声抱歉，确实是我之前没准备好，没有提前给手机充好电，导致沟通不太顺畅，没有发挥自己正常水平，给面试官造成了不好的面试体验。

晚上回来，按着面试官您给我打的电话拨过去，客服那边说联系不到您，所以我后来想着只能通过邮箱联系您了，我其实对自己感觉不太满意，所以就在今天晚上抽空重新整理了一些回答，期望和面试官可以进行后续的探讨，谢谢！



> Date:2019/04/25
>
> Mail: rongweihe1995@gmail.com
>
> GitHub:https://github.com/rongweihe



目录

[TOC]



### 1、进程间，线程间通信方式（**Linux系统下**）

#### 五种进程间通信方式

1、**pipe 匿名管道 FIFO 命名管道**

管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

2、**消息队列**

消息队列是消息的链接表，包括 Posix 消息队列 system V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

3、**信号量**

**（semaphore）**：主要作为进程间以及同一进程不同线程之间的同步手段。

4、**信号**

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux 除了支持 Unix 早期信号语义函数  sigal 外，还支持语义符合 Posix.1 标准的信号函数 sigaction（实际上，该函数是基于 BSD 的，BSD 为了实现可靠信号机制，又能够统一对外接口，用 sigaction 函数重新实现了 signal 函数）；

5、**共享内存**

使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式**。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

#### 六种**线程间通信方式**

1、 **互斥锁** 确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。

2、**读写锁** 当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。

3、**条件变量** 可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

4、**自旋锁** 上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

5、 **信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量

6、**信号机制(Signal)**：类似进程间的信号处理。



### 2、MYSQL数据库几种索引类型？分别讲一下简单使用。

思考：这一块数据库的知识确实还需要加强弥补，

对于 MySQL 索引类型目前主要有以下几种索引类型：

**FULLTEXT**（全文索引，目前只有 MyISAM 引擎支持。其可以在 CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用）。

**HASH**（hash就是一种（key=>value）形式的键值对，如数学中的函数映射，允许多个 key 对应相同的 value，但不允许一个 key 对应多个 value）。

**BTREE**（一种将索引值按一定的算法，存入一个树形的数据结构中）。

**RTREE**（在 MySQL 很少使用，仅支持 geometry 数据类型，优势在于范围查找）。

几种索引的使用情况总结：

【1】对于 BTREE 这种 MySQL 默认的索引类型，具有普遍的适用性。

【2】因为 hash 表在处理较小数据量时具有一定的优势，所以 hash 索引很适合做缓存（内存数据库）。如 Memsql，Mencached，redis 等，都使用了 hash 索引这种形式。



### 3，假设 12306 网站现在有 1200 张票，但是同一时间有 2000 个客户买票，如何解决超卖现象？

思考：

对于这个问题，由于之前没有接触过类似的业务，所以不是很了解，目前网上查到的回答有：

- 库存超卖问题是有很多种技术解决方案的，比如**悲观锁，分布式锁，乐观锁，队列串行化，Redis原子操作**，等等。
- 这里说一下自己对**分布式锁**的一个理解：同一个锁 key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行相应的业务逻辑。但是后面具体如何实现的，这一块就不是太懂了。

这方面的知识自己目前还不是很懂，希望能和面试官进一步讨论学习。



### 4、一棵树层次遍历存到数据库，请问数据库表如何实现？有哪几个字段？



思考，想到两种方法：

**1、数据库表保存五个字段，分别是自身ID，自身结点值，左子树ID，右子树ID，父亲结点。**

| selfID | selfIValue | leftID | rightID | parentID |
| ------ | ---------- | ------ | ------- | -------- |
| 1      | A          | 3      | 4       | 0        |

这种结构下，如果查询某一个节点的直接子节点，比如要查询跟节点的子节点:

**select** * **from** tree1 **where** parentID = 0

如果要插入某个节点，比如在A节点下，再次插入一个节点:

**INSERT** **INTO** tree1 (selfValue,leftID,rightID,parentID) **VALUES**('B',5,6,1);



**2、可以理解为路径枚举法。将存储根结点到每个节点的路径。这种思路比较简单易懂**

| selfID | selfIValue | path |
| ------ | ---------- | ---- |
| 1      | A          | 1/   |
| 2      | B          | 1/2/ |



不知道这样设计是否正确，对于数据库这块的知识自己确实掌握的不太好，希望能和面试官进一步沟通和学习。



### 5、堆排序的应用场景

目前想到的几种场景。

**1、 将 k 个已排序链表合并为一个排序链表的算法。**


思路：使用最小堆，体会到在动态的序列中堆的优势。

假设 k 个链表都是非降序排列的。

（1）取 k 个元素建立最小堆，这 k 个元素分别是 k 个链表的第一个元素。建堆的时间复杂度 O(k)。

（2）堆顶元素就是 k 个链表中最小的那个元素，取出它。时间复杂度 O(1)。--只要在最小堆中保证每个序列都有一个元素，就可以保证最小堆取出来的一定是当前的最小值。

（3）若堆顶元素所在链表不为空，则取下一个元素放到堆顶位置，这可能破坏了最大堆性质，所以进行堆调整。堆调整时间复杂度 O(lgk)。若为空，则此子链表已经被合并完毕，则删除最小堆的堆顶元素，此时最小堆的 heapsize 减小了 1 。删除指定元素时间复杂度 O(lgk)。

（4）重复步骤（2）~（3）n-k次。总的时间复杂度是 O(k)+O(nlgk) 即 O(nlgk)。

**2、海量数据求前 K 大**

**解决思路：**

1、取列表前 K 个元素建立一个小根堆。堆顶就是目前第 K 大的数。

2、依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；

3、遍历列表所有元素后，倒序弹出堆顶。



**3、实现优先队列**

优先级队列，顾名思义，它首先应该是一个队列。队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。

如何实现一个优先级队列呢?方法有很多，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素，从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。

很多数据结构和算法都要依赖它的实现。比如赫夫曼编码、图的最短路径、最小生成树算法等等。不仅如此，很多语言中，都提供了优先级队列的实现,比如, Java 的 PriorityQueue, C++的 priority-queue等。

**4、快速获取 TOP 10 最热门的搜索关键词**

假设现在有 10 亿个关键字，如何处理

一个思路：

- 创建 10 个空文件00, 01 , 02., ...0 9。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。
- 对这 10 亿个关键词分片之后，每个文件都只有 1 亿的关键词,去除掉重复的，可能就只有 1000万个,每个关键词平均 50个字节，所以总的大小就是 500MB, 1GB 的内存可以放得下。
- 我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10,然后把这个 10 个Top 10 放在一块,然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的Top 10最频繁的搜索关键词了。



### 6、栈和队列的应用场景

**栈的一些典型应用：**

**1、符号匹配**

比如说经典的括号匹配问题：简单说一下思路：循环一遍，遇到左括号的入栈，遇到右括号比较此时栈顶元素是否对应的左括号，即判断是否匹配，匹配则弹出栈元素，直到最后栈元素为空说明整个括号匹配，否则不匹配。 时间复杂度O(n),空间复杂度O(1) 。

**2、表达式转换和求值**

利用栈的先入后出的特点

**3、深度优先搜索**

**4、函数调用**

这个简单说一下自己的理解：比如说，当前函数 fun1() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 fun2()，而 fun2() 也要求使用寄存器，为了防止数据丢失并且在执行完 fun2() 能够返回到 fun1() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。

这样 fun2() 函数就可以使用寄存器了。fun2()  函数执行结束就取栈顶的返回地址继续执行 fun1() 。如果 fun2() 中又调用另外一个函数，相应的操作也是一样的。

**队列的一些应用**

公平且经济地对社会资源做管理或分配的场合，比如说银行和医院的服务窗口。队列的先进先出保证了公平性。

计算机及其网络自身内部的各种计算资源，多进程共享的 CPU 时间；多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。

　　1．共享打印机

目前，打印机提供的网络共享打印功能采用了缓冲池技术，队列就是实现这个缓冲技术的数据结构支持。每台打印机具有一个队列（缓冲池），用户提交打印请求被写入到队列尾，当打印机空闲时，系统读取队列中第一个请求，打印并删除之。这样，利用队列的先进先出特性，就可完成打印机网络共享的先来先服务功能。

　　2．消息队列

操作系统中的消息队列也是队列的应用之一，消息队列遵循先进先出的原则，发送进程将消息写入队列尾，接收进程则从队列头读取消息。

队列是先进先出，不允许有任何元素插队，这对于解决现实生产问题有很大帮助。

**共同优点**：栈和队列的操作的时间复杂度都是O（1），效率非常高。



最后，希望能和面试官能交个朋友，后续多多交流和沟通，谢谢！