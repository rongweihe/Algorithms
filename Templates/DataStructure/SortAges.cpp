题目：某公司有几万名员工，请完成一个时间复杂度为O(n)的算法对该公司员工的年龄作排序，可使用O(1)的辅助空间。

分析：排序是面试时经常被提及的一类题目，我们也熟悉其中很多种算法，诸如插入排序、归并排序、冒泡排序，快速排序等等。这些排序的算法，要么是O(n2)的，要么是O(nlogn)的。可是这道题竟然要求是O(n)的，这里面到底有什么玄机呢？

                题目特别强调是对一个公司的员工的年龄作排序。员工的数目虽然有几万人，但这几万员工的年龄却只有几十种可能。上班早的人一般也要等到将近二十岁才上班，一般人再晚到了六七十岁也不得不退休。

                由于年龄总共只有几十种可能，我们可以很方便地统计出每一个年龄里有多少名员工。举个简单的例子，假设总共有5个员工，他们的年龄分别是25、24、26、24、25。我们统计出他们的年龄，24岁的有两个，25岁的也有两个，26岁的一个。那么我们根据年龄排序的结果就是：24、24、25、25、26，即在表示年龄的数组里写出两个24、两个25和一个26。

                想明白了这种思路，我们就可以写出如下代码：
void SortAges(int ages[],int n)//桶排序
{
    if(ages == NULL || n<=0) return;
    const int oldAges = 99;
    int timesage[oldAges + 1];
    for(int i=0; i<n; ++i) timesage[i]=0;
    for(int i=0; i<n; ++i)
    {
     int age = ages[i];
     if(age<0 || age > oldAges) throw new std::execption("age out of rang");
     ++timesage[age];
    }
    int index = 0;
    for(int i=0; i<=oldAges; ++i)
     {
      for(int j=0; j<timesage[i]; ++j) 
         { ages[index]=i;++index;}
     }
}
    在上面的代码中，允许的范围是0到99岁。数组timesOfAge用来统计每个年龄出现的次数。某个年龄出现了多少次，就在数组ages里设置几次该年龄。这样就相当于给数组ages排序了。该方法用长度100的整数数组辅助空间换来了O(n)的时间效率。由于不管对多少人的年龄作排序，辅助数组的长度是固定的100个整数，因此它的空间复杂度是个常数，即O(1)。
